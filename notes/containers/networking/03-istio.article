Istio
|| Last update: 26 Jan 2018

* Intro

- [[https://istio.io][Istio website]]
- [[https://github.com/istio/istio][Istio github]]

*IMPORTANT*: *Istio*is*very*immature*.*Don't*use*it*in*any*MAJOR*environment*.

*IMPORTANT*: The user contract won't stabilise until version 0.4.

Istio is not a k8s technology and can work with other orchestrators.

The goal of a control plane is to set policy that will eventually be enacted by the data plane.
Provides policy and configuration for all of the running data planes in the mesh.
Does not touch any packets/requests in the system.

- Data planes: Linkerd, NGINX, HAProxy, [[https://www.envoyproxy.io/][Envoy]], Traefik
- Control planes: Istio, Nelson, SmartStack

Linkerd one of the first (early 2016 - [[https://buoyant.io/2016/02/18/linkerd-twitter-style-operability-for-microservices/]]).
Envoy 6 months later ([[https://eng.lyft.com/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191]]) (but in prod in left since 2015).

    The network should be transparent to applications. When network and application
    problems do occur it should be easy to determine the source of the problem.
    — Envoy

Istio announced in May 2017. Default proxy of Istio is Envoy.
Istio has garnered a lot of excitement, and other data planes have begun
integrations as a replacement for Envoy (both Linkerd and NGINX have
demonstrated Istio integration)

Nelson and SmartStack help further illustrate the control plane vs. data plane
divide. Nelson uses Envoy as its proxy and builds a robust service mesh control
plane around the HashiCorp stack (i.e. Nomad, etc.). SmartStack was perhaps
the first of the new wave of service meshes. SmartStack forms a control
plane around HAProxy or NGINX

* What is a service mesh

- [[https://en.wikipedia.org/wiki/Mesh_networking]]
- [[https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/]]

    A service mesh is a dedicated infrastructure layer for handling
    service-to-service communication. It’s responsible for the reliable
    delivery of requests through the complex topology of services that
    comprise a modern, cloud native application. In practice, the service
    mesh is typically implemented as an array of lightweight network proxies
    that are deployed alongside application code, without the application
    needing to be aware.
    - https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/

.image images/service_mesh_color.png

The control plane enables the proxies to implement things like access control
and metrics collection, which requires cooperation:

Two benefits of this approach are already evident to me. First, not having to
write custom software to deal with what are ultimately commodity code for
microservices architecture will allow for many smaller organisations to enjoy
features previously only available to large enterprises, creating all sorts of
interesting use cases. The second one is that this architecture might allow us
to finally realise the dream of using the best tool/language for the job without
worrying about the availability of libraries and patterns for every single
platform.

.image images/service_mesh_black.png

.image images/service_mesh_generic.png

* What is Istio

Istio is a distribuited control plane to configure envoy system records for
service mesh.

.image images/istio_arch.svg _ 750
.caption Source: [[https://istio.io/]]

.image images/all_istio.png _ 750
.caption Source: [[https://www.youtube.com/watch?v=IfPt3z6UAGw][JavaDay UA 2017: 8 Steps to Become Awesome with Kubernetes (Burr Sutter)]]

Istio is a:

- Network mesh
- Cluster wide policy enforcer (for access control)
- In depth telemetry exporter

Is very useful to help connect _legacy_ and _distribuited_. It helps to separate:

- Run-time
- Configuration
- Context

Like:

- Routes
- Firewall routes
- Security context

* Installing Istio

** Requirements

Requires kubernetes *1.7.4+*

Istio now uses CRD (CustomResourceDefinitions) so it needs k8s 1.7.4+.

You can install it manually but is not covered by this page.

** Helm

- [[https://github.com/kubernetes/charts/tree/master/incubator/istio]]
- [[https://istio.io/docs/setup/kubernetes/sidecar-injection.html#automatic-sidecar-injection]]

Helm is a two step installation.

    #https://github.com/kubernetes/charts/blob/master/incubator/istio/templates/service-account/initializer.yaml
    helm install --name istio \
      incubator/istio \
      --devel \
      --namespace istio-system \
      --set istio.release=0.4.0,initializer.enabled=true,rbac.install=true
    helm upgrade istio incubator/istio --devel --reuse-values --set istio.install=true

If you are not on AWS the update can be:

    helm upgrade istio incubator/istio --devel --reuse-values --set istio.install=true --set ingress.service.type=NodePort

THIS????

    kubectl create clusterrolebinding add-on-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default
    helm install --name istio incubator/istio --devel --namespace istio-system --set istio.release=0.4.0,initializer.enabled=true

*** Possible errors

    Error: UPGRADE FAILED: apiVersion "admissionregistration.k8s.io/v1alpha1"
    in istio/templates/initializer/initializer.yaml is not available

In case you don't have the initialiser (alpha) enabled.

*** How to test it worked

    cd Downloads/istio-0.4.0/
    kubectl get deployment sleep -o yaml
    kubectl apply -f samples/sleep/sleep.yaml
    kubectl get pods
    echo $(kubectl get deployment sleep -o jsonpath='{.metadata.annotations.sidecar\.istio\.io\/status}')

* Structure

The structure is very similar to kubernetes. It has a concept of control plane.

- envoy (data plane)
- pilot
- mixer

istio is a unified control plane.

** Envoy

.image images/envoy.svg _ 750
.caption Source: [[https://istio.io/]]

- [[https://www.envoyproxy.io/]]

    Envoy is a self contained process that is designed to run alongside every
    application server. All of the Envoys form a transparent communication mesh in
    which each application sends and receives messages to and from localhost and
    is unaware of the network topology.

Envoy is a distruited data plane.
Data planes by themselves do nothing. They need to be configured by something larger.
Other example of data plane are:Linkerd, NGINX, HAProxy.

Service mesh data plane (via sidecar):

- service discovery
- health checking
- routing
- load balancing
- authentication and authorisation
- observability (statistic, trading and logging)

While _haproxy_ and _nginx_ are *config*file*hub*, envoy is made to receive
orders from pilot. The data plane is responsible for conditionally translating,
forwarding, and observing every network packet that flows to and from a service instance.

Envoy lives in a sidecar in each pod. There are two ways to configure it:

- use a tool to inject
- using an initialiser (kubernetes)

.image images/sidecar.png _ 750
.caption Source: [[https://medium.com/@mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc]]

The initialiser works by telling k8s that before you run a pod, inject the stuff.
The user doesn't need to know. When _things_ change, envoy changes.

envoy is both a _sidecar_ for all the data and serve as _ingress_ and _egress_.

Envoy knows of all the other envoys and so on.

*** How does it work

Sidecars in this case are network proxy.

All network traffic flows via it’s local sidecar proxy to the appropriate destination.
Service instances are not aware of the network at large and only knows about it’s local proxy.
The distributed system has been abstracted away from the service programmer.

** Pilot

.image images/pilot.svg _ 750
.caption Source: [[https://istio.io/]]

_Envoy_ has been fully rewritten in C - is connected to a distribuited system and
highly dinamically configurable.

Pilot is a system of record for the server mesh. All envoy receive the same
configuration and dinamically changes the configs for envoy.

Pilot is also abstracted from the underlying platform and use adpters to
communicate with the platform. istio has a kubernetes adapter but IS NOT made for
k8s.

.image images/control_plane.png _ 750
.caption Source: [[https://medium.com/@mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc]]

istio and translate in ingress and other network rules is something Istio can
understand.

Plus, it has a plugging api for routing and other stuff like:
- black hole
- ingestion

** Mixer

.image images/mixer.svg _ 250
.caption Source: [[https://istio.io/]]

Is the policy engine: telemetry, billing, quota and so on.

If you want an API gateway you usually will put on something like Kong. *Mixer*
is the component of Istio that takes decisions.

Mixer has plugins for tracing, prometeus and much more.

Unfortunately (as of 2.9), you still need to fork, build and maintain the code
yourself if you want to add a new functionality to mixer. They are working on modularity.

There is a lot of metadata that is aggregated and send it to mixer so you can do
rules and so on.

All expressed under the hood as CRDs.

* Capabilities

.image images/capabilities.png

** Mutual TLS

.image images/mutual_tls.png _ 800
.caption Source: [[https://www.youtube.com/watch?v=wq1nlJNvy1w][Setting Sail with Istio [B] - Lachlan Evenson, Microsoft]]

Before this was before based on top of vault, but is was clunky and not working
well.

- it uses k8s enabled stuff
- all service communication and tsl
- all communication is encrypted
- and lifecycle of certificates is managed by istio

** Deployments

Istio can give you out of the box tools like _canary_deployments_.
Sending a percentage of the traffic to a new version of your service.

K8S already have _rolling_deployments_ under the cover, but what if you want to filter traffic by:

- tokens
- headers
- network

and much more, Istio can help you.

** Access control

k8s have _network_policies_ but they have problems:

- They are op focused (and devs usually don't do them)
- They are more cluster side
- Difficult to write

** Ingress

Istio doesn't work with nginx ingress containers (http1 problem?).

Some people replaced nginx with Traefik (very low footprint)

** Egress

While k8s have ingresses, it does not have egress. *Egress* is a new way to funnel all
the traffic exiting my cluster through a deployment group.

As a DEV they know if an application needs or not external access, and this allow them to
_close_ egress access.

** Telemetry

Istio will give you access to app telemetry without having to instrument the
application itself. You can add and have this metrics without having to go
through the DEVs.

** Tracing

Tracing is not about debugging you application, is about debugging the _process_.

Debugging is hard in k8s:

- kubectl proxy
- run a debug pod
- inject debug (sidecar) containers
- mTLS is hard!

Istio will inject headers, but you need to *forward* them in the code.

    NO FRAMEWORK WILL SAVE YOU FROM BAD CODE

** API gateway

    API gateway ~= Ingress

* Technologies

- consul support
- opentracing
- vault support
- nginx
- prometheus
- spify ???? (secrets?) identy to application

sits in datapath, map events

* Istio and Rancher

It will probably be integrated in Rancher soon.

    # From a QA in October 2017
    Q: Any plans on supporting Istio in Rancher 2.0?
    A: :)

* Usage

How do you make it so that is applies?
It uses sidecars.
You build a config pushed on every node.

You don't need to instrument your code
Attach functionality to the system

attach sidecar without changing the yaml
add a second container
grab info from the data plane

add zipkin so you have tracing

** Option 1: Initialisers

*From*v0.2*only*

For the newer versions you can use [[https://kubernetes.io/docs/admin/extensible-admission-controllers/#enable-initializers-alpha-feature][_initialisers_]]
to avoid having to inject yaml with istioctl all the time. _initialisers_ are pretty new to k8s so you may
need to abilitate them via the alpha API.

_initialisers_ allow you to have *automatic*sidecar*injection* in all your pods.

    before ???

** Option 2: The old way

    istioctl kube-inject -f

* Changelog

There is no changelog, this is the best we have:

- [[https://github.com/istio/istio/wiki/v0.2.9]]
- [[https://istio.io/about/notes/][Release notes]]

Notable changes follow.

** 0.3

- HA
- Better RBAC support
- Mutual tsl

** 0.2.6

- [[https://github.com/istio/istio/wiki/v0.2.6]]
- RBAC beta
- Initialisers

* Resources

- Me: Notes from London Kubernetes Meetup -  October 2017
- Video: [[https://www.youtube.com/watch?v=wq1nlJNvy1w][Setting Sail with Istio [B] - Lachlan Evenson, Microsoft]]
- Video: [[https://www.youtube.com/watch?v=Bh7sWtrkijY][Istio 0.2 automatic sidecar injection using Kubernetes Initializers]] - 6 Oct 2017
- [[https://www.youtube.com/watch?v=s4qasWn_mFc][Youtube: Istio and Kubernetes - Kelsey Hightower]] Jul 2017
- [[https://www.safaribooksonline.com/library/view/velocity-conference-2017/9781491976265/video311439.html]] (safari book)
- [[https://www.youtube.com/watch?v=IfPt3z6UAGw][JavaDay UA 2017: 8 Steps to Become Awesome with Kubernetes (Burr Sutter)]]
- [[https://www.youtube.com/watch?v=wq1nlJNvy1w][Setting Sail with Istio [B] - Lachlan Evenson, Microsoft]]
- [[https://medium.com/@mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc]]
