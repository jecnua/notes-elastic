GO
|| Last update: 17 Feb 2020

* TO BE SORTED

var in go allows us to 0 value the variables and is very important to avoid
corrupt state

string is a 2 words data structure
first parr is a pointer the rest the nukber of bytes

:= pre initialise a variable so you don't need to zero it before (and don't need
var)

pascal had a lot of influence  in go

is more for productivity productivity operator
go is struct based typing

go doesn't have type casting it only have conversion.
the value will be copied in the new type.

alignment: to make reading and writing from memory efficient. a struct size is
not the sum of the xomponents. is because of hardware.

since boundaries are at word level you don't want a type to cross the coundary
of two words

the hardware will need two operations to read and 2 to write


struct is a user defined value
we don't create classes in go, we declare values

optimize for correctness
order fields from largest to smallest
struct must align on the largest field

the language doesn't go behind your back and rearrange so you don't lose view of the impact
alignment and padding

{} literal constraction
return or function calls are a good place for empty literal constructuin

literals are unonimous struct
unnamed type

you can declare and assign one after the other for non zero anonymous struct

used for unmarshaling. naming something used only in one place would be pollution

go have no implicit conversion

in go you don't need to convert with unamed types. if it's litera you ca assign
to something else. this is used with function

function is a literal in go not a type

so to recap
with name types there is no implicit conversion

all in go is pass by value

each go applization gets a P (logical processor - one core) for each core it can
see. this P gets a M (real operating system threads) and the M is scheduled a
real core ln the system called C. P also have goroutines. (g).

threads M are path of execution at operating system level
g are a  is in the path of execution at go level.

there are 3 areas of memory
- data segment - global values
- stack (every thread is given)
- heap

a stack is given to any real thread
usually 1Mb of contiguous memory

g have a stack of memory too. now is 2k (before was 4k).
this is because we want to have a lot of goroutines or path of execution in go.
integrity and minimizing the memory impact

at a certain point it says I want to execute the main()
each time it need to execute a function it tales memory off the stack
this is called "frame of memory"

the go routing have only direct access of memory
on the frame is working on
this mean that if you need to work on data you need to have the data in that memory frame

mechanics how things work
semantics how things behave

active frame is which part (isolated) of the stack it's working on

data semantics
pointer semantic

pointers are used to share data between function stacks

pointers is literal types
you can take any existing type and put a star on it

the reason why you can't just say * but you have to say *int is because you will
need to manipulate the data structure in memory and you need to know how the
structure IS. size and all.

*inc++
indirect data access
pointer indirection

only direct memory access in the active frame
so you need to pass the pointer to do so

there is a huge cost to pointers
there is no more immutability
but you have side effects

you can have race in multi threaded
so some languages won't allow you to
but there is a cost to it too

no memory AFTER the the active frame is VALID
everything below the active frame
memory is no loger valid
going down will cause problems


we don't have contractor in in go
but we have factory functions

creates a value and initialise it for you and returns it


the compiler does something called
escape analysis
- [[https://www.ardanlabs.com/blog/2017/05/language-mechanics-on-escape-analysis.html]]
or first priority is that something stays on the stacks
stacks is self cleaning

or escapes to the heap
compiler
allocation in go
escape analysis realises that a value cannot be created in the stack but needs
to be on the heap
and now the gc is involved

we really want to try to leverage the stack

the compiler will construct immediately on the heap

if you want to access any type of memory that is not on the active frame you
can do it with a pointer

don't mix semantics
NEVER use pointing semantics during constraction
don't do

u := &user

so don't assign it to a variable

[[https://www.ardanlabs.com/blog/2018/01/escape-analysis-flaws.html]]
[[https://docs.google.com/document/d/1CxgUBPlx9iJzkz9JWkb6tIpTe5q32QDmz8l0BouG0Cw/edit#]]

when you use the -gcflags "-m -m"
you will get the escape analysis report

profiler tells you ony what is allocating not why



if the compilers doesn't know the size of something at compile time
it will need to put it on the heap
things like collations doesn't know
this causes automatic allocation

go run -gcflags '-m -l'  ??

integrity first
minimize resources second


when we run out of stack state
we need new stacks

contiguos stack
allocate a larger stacks2
25% of the original one
then copy all to the other one
will get a little of latency hit
and it will

we take this hit to ensure consistency and minimize resources

values in the stack can be moved around


go engineering choices
NO STACK can have a pointer to another stack
otherwise they could not grow
the only pointers to a stack is to your stack

you need to use the heap to share values between goroutirng

goroutings cannot share pointers

what goes on the heap
- what escape
- sharing data between goroutings
- we don't know the size beforehand

* GC

latency etwork and disk io
second is allocation and garbage collector

tri color
mark and sweep
concurrent collector

is not a compacting garbage colletor
it doesn't moved

they still have some stop the world latency
reduced to the bare minimum

pacing algorith try to balance 3 things
- smallest heap size
- run at a reasable pace to do it
- no more than 1000microseconnd per run

the total gc time will be longer but the stop the worls will be lower

CAN take 25% of the CPU capacity
the gc is allowd to use?

the gc uses goroutines as well

** Pace algorith

go prefer consistent pace over a QUICK gc

size of the heap and live heap
the moment you get close enough to the top

when the heap reach the top it will need to grow and go have something called
GOGC 100% growth

if a gorouting starts to go rogue during a gc
the gc can reallocated the goroutine
and do other things

** Stop the world

2 ones

the right barrier one should be relly quck
his go routing need to report in what are doing
to keep the scheduler and gc intellingent

all the Ps they need to bring all of them to a save point
bring them somewhere and set a flag
wait for a gorouting to do a functioncall
1.10

only way to do a fucntion call
waiting for a gorotuing to do a funciton calls
this is because we don't have a preemptive schedulerbut cooperative scheduler
cooperation

if you do any high level mahematics you need to do function call
they are working to do it at static level
but is complicated.

we need to have goroutines make function call.

maybe 10 microseconds tops o do the right barrier

the heap is a very large graph
all starts

let's not use global variable
testability
hide costs
etc

tri color
we turn all of the values stack and xxx as WHITE
as you scan them you paint them black
and root values are painted gray
placed in a queue
paint it black if...

iterate over the entire three
when we are done there are only balck and white
black needs to stay
anything that is white is deleted in the NEXT phase

this marking is done concurrently

xxx

search for a papers

we should try to balance our pointer semantincs
less work for the compiler the better

* Constant

two types

- constant of a kind they are unamed constant
- constant of a type

Constants only exists at compile time

const are of a "kind" in go
choosen during assignment

they are not read only var like in other languages

constant of a type
constant of a kind give flexibility


constant of a kind have no type at delcaration
typed constant do

Kind promotion???
tells you how things promote

const of a kind they ar enot type based
they are technically bot bound by precision

you can have inplicti conversion between type

technically unamed constant of a kind

if you use a typed int you can trick the system to promete a number to the type
you need.

constant of a kind can be implicitly converted

constant can only be build in type
vecause they only exist at compile time

there is no enumeration in go??


iota?

inside a const block
iota will increment each variable by 1

* Data oriented design

- [[https://en.wikipedia.org/wiki/Data-oriented_design]]

Every problem you solve is a data problem.
Decouple functions from the data because data will change

deal with change

mechanical sympathy

Only types:

- arrays
- slice
- maps (creates contigues memory)

** Array

No data structure

list/queue/stacks

linked list package in go
there is the package

slices is everywhere in the language
build in in the standard library
core data structure of the language

_tets.go

Benchmark
*testing.B
find the benchmark function
and you need to put it in a function
and call is b.N
you should run it in a idle machine

the go complirer to recompile the code
assign to a local and a global
so the copiler doesn't throw it away

    go test -run none -bench . - benchtime 3s

test run test functions

cpu caches matter

if performances matter
main memory is too slow
so we have to fix everything in xmb (l1+l2+l3) of memory
(your memory)
total amount of memory you have
i the total cache

small is better
need to fit in the cache and stay there


cache lines
64 bytes of memory
when you have to load all the memory
if will be split that way

when you move a cache in you will move something out
we would like to have this information in cache BEFORE we need it

how can we create a situation
so that a cache-line stays inside l1 and l2
we need code that have "predictable access pattern to memory"
mecahnical sympathy

if you allocate contigue memory
and access is predictable patter

pre-fetcher can pick this

array is the best way to do it

pre-fetcher and hardware loves array

the slice however is the most important
structure in go (underline is a vector)
slices is actually a vector

vector

linear iteration
predictable access pattern in memory

OS access memory based in pages

tlb cache is important too
it does creates a cache
of virtual addresses
to pages and physical location

when you say get this virtual address
tlb makes a lookup
for where is physically located in memory

tlb is small
in a tlb miss you need to search for it
traversal of paging tables
tlb miss is heavy

predictable access helps the tlb

no linked list, stacks, queue and so on
because you can't have mechanical sympathy
the JVM is helping you to do this

in go you don't have a vm
so you are the one responsible for it


* Array

size of an array needs to be knows at compile time

go only uses for
normally - for range (4 semantics)
like a while

our job is to identify and balance
to minimize the allocation
string is focalised on that


for i = works on the array
for i, v <= value sematic, works on a copy of the array

the data drive the semantic

don't do this for i, v   &array NO!

* Slices

make()
3 of the reference type

make(string[],5,8)

until now built in and our
third one is the reference type

maps
channels
interface
functions

they are data structure with a pointer

when they are 0 values they are a nil

they are similar to how string gets created
they are formed by 3 things
- a pointer
- the length
- and capacity

capacity is the number of element you can access from that array
capactity can be as much or more than lenght (not less)

capacity is for efficient growth

is supposed to be used with value semantic

len()
cap()

slice []string

two operations:
we append things
and we slice them

zero slice var data []string
empty slice data := []string{}

there is also another thing
called the empty struct

var es struct{}
is a zero allocation struct

there is a 8bit value in the architecture this thing is pointing to!!!!
they all have the same address

append(data,value) value semantic mutation api


if append needs to raise the capacity of a slice
then it will create a copy of the slice and the old one will be GC
if nobody is poiting at it

when you use append make sure you are saving the same slice you are appending

    test = append(test, value)

append will double the capacity of the slice if there is no space

after you reach 1024 bytes append won't double anymore but grow of 25%

** what is a memory leak in go

here escape analysis

a memory leak in go is when you keep a reference to a memory in the heap and this
never goes away
you can't instrument for memory leak when is reference based

check the GC trace

you don't want to see the memory go up in every GC run

possible issues:

- go routing that don't close
- maps (usade for caches. you need to drop them. delete keys)

** slice

[a:b]

they share the same backing array

if you don't know your lenght
you should not be slicing

better to think

[a:a+lenght]

the "capacity" of the new array is calculated based on the old one (remaining slots)

also append changes will reflect in both slices
if you are sharing them

if append needs to EXTEND the slice, it will create a copy
so no changes on the old one
copy on write

slice(2,3,2)

* copy slice

copy(slice1,slice2)


be careful with append
because it could be a smeel
and can cause a lot of side effect

** for with ranges

for range
with value semantic
will make a copy of what you are working on

for _, v :=

pointer semantic of for

for i :=

* Maps

key value place

convention over configuration (go)

maps are randomised
every time you pick value form it is random (if you use dfor)
on purpose not to make you base your code on order

delete()

allow to remove a key from a map

u, found := user["test"]
#found is boolean

to validate if a key exists or not

key can be something they can hash
like something you can use in a IF

go added the sort library

* Decoupling

Deecoupling is done with behaviours
design architecture

go has functions and method
method are functions with a reciever

func (u user) notify () {}

u user is the reciever

when should a piece of data have behaviour???
should be the exception not the rule

functions first choice

but when use a method?

you can use value reciever or pointer recievers

this and self???? are the java version of recievers?

when using a method go only cares of the data type
doesn't care if is a value or pointer

NOTE: don't start with pointer semantic on construction

* When use pointer semantic and when value semantic

3 classes of types (of data)

built in
- numeric
- string (immutable and)
- bool
USE VALUE SEMANTIC (copy) - including fields in a struct
exception: marshalling and unmarshalling data when working with DB


reference:
- slices
- map
- channels
- interface values
- functions
VALUE SEMANTIC for all
don't take the address of a reference
exception (slice and map): only if you sharing down the call stack to a function
decode and unmarshal


user defined types:
- struct
choose what is in play for your struct
if not use use pointer semantic
but if you can use VALUE SEMANTIC


keep the heap clean with value semantic



a method can return a copy of the value
so you can use value semantic for reference type
this allows changes in isolation

possible question to ask:

- if I give you a simple of the data and need to mutate, is the new one
a different value or the same one?
when mutation doesn't create a new piece of data


Factory function (function that return the Type)
always come before the type
and tell you the semantic is in play

if something is shared, so the factory returns a pinter
start  y thiking that it could be dangeours to share!

if you type choose a semantic stick with it
so if you choose pointer smentic for a type
keep it for functions
EVEN if you don't mutate



when data needs behavior?
the less as possible

setter and getter are not an API
bloat and gives no benefits
not providing anything good

methods internally gets translated in go

d is a user
d.changeName()
becomes
user.changeName(d)


functions in go are types
you can assign them
and pass them around


two word fata structure
point to the code of display name
and the second point to the data (copy or address)


when you have double indirection
the escape analysis
will allocate the data\
because he can't know if he can leave it on the stack
so decoupling have a cost





* Interfaces (DO BETTER)

Allow us to implement polymorphism.

a piece of code changes it's behaviour
depending on the concrete data

one good reason for a pice of data to have behaviour
is when you need to implement polymorphism

or a stateful api

type reader interface {}

interface is a type
you can create a var interface

interfaces are not real
there is nothing concrete
only define a method set of behaviour
a contract of behaviour

interfaces are about behaviour
they are not classes
not THINGS they are behaviour

don't allocate on the heap every time you
make a call
so don't return an byte[]
so avoid allocation
because you need to use a make() inside the function
and "return" it back
because you can't have a pointer back to the stack
or use a MAKE depending on the size

instead create an array and pass it!

go is convention over configuration:

func (file) read(x,y) (z, error){}

interface method set
all the function of an interface

data oriented design

interface types are values

when interface is set ot zero value
is nil,nil

there is a relationship
we store data inside the interface value
and make it concrete

is the second word that is storing the value

the first work of an interface
pint internally
to a table called
iTable (is like a vTable)
matric of function pointers
it will always describe the type of value
we are storing
the rest of the itable it the function pointer
concrete implementation of the method

interface give a level of de coupling
when you call a method on an interface
it does a lookup in the iTable
to find where the implementation of that method

indirection and allocation
this is what polymorphism costs us

you can implement via pointer semantic
or concrete
func (*file)

methodsets

set of rules in the specification

only this method using value reciviers
implement the interface

all the method you declare for that

the value data -> have value reciever
pointers have -> pointer reciveres and value recievers


------------------
T | NOTHING | value recievers
------------------
*T | pointer recievers | value recievers
------------------

we can't include pointer recievers for value
just for pinters

MINOR INTEGRITY ISSUE
not every value have an address
(something can't be shared)
like CONST (they only exists at compile time) - no stack or heap

MAJOR INTEGRITY ISSUE
if yopu choose pointer semantics
sharing is the ony safe things to do

sometimes you can share a value semantic - exceptions (like unmarshal)

you cannot assume is sage
is never safe to copy
of a value that a pointer points to

decoupling comes at the cost of indirection and allocation

mechanics -> semantics -> code

when you use value semantic in an interfsace you have
User and * to a copy of User
wih pointer semantic you hvae
*User and * to the original User

interface needs to be looped
in value semantic
because interfaces uses value semantic

* EMBEDDING

inner type and outer type
inner type promotion

anything in the inner type
can be promoted to the outer type

you access via che inner type name
or not

ad.user.notify
ad.notify

embedding will allow the outer class
to respect the interface
because it satisfies the interface

is not a subtype relation

outer class IS NOT the inner class
and cannot be used as much

what if the outer type implement the interface?
in this case there is not promotion
the outer type will override the inner type
implementation

you can still access the inner type implementation
via the inner class.

only during compile type this implementation are
accessed

so if you two inner types
implements the same function
nothing hppens unless you try to call it

* Composition

Basic unit is a packge
packacge is a folder
a folder is a static library

smalles unit of compilation

the directory inside is should be the namespace
and there should be at leasrt one file inside
with the same name as the dir

symbols are exported or unexported
the exported is available outside

match the folder name and the package name
because wer expect this to match

all the code in the dir should use the the package

type Start with the Capital letter
all that starts with a capital caase
and is exporter

import points to your gopath location

IS ALREADY a relative path


very coomon to have factory function with the
name New

the linter will tell you if something is not good

this also works inside the struct
if you have two capital and one lower

if a exported struct uses an inner struct that is unexported

beware

things are promoted and is strange
you can access it if the inner struct types are capital
BUT you won't be able to initialise

JUST BE CONSISTENT

is not a public/private like other languages
is just about is it accessible or not

* Composition

** Grouping

there is no subtyping and not subclass
embedding doesn't link two types

go is convention over configuration

group things about the behaviour not what they are

avoid a generic type added only forz
reusable state

do not use struct instead to avoid copy-oasting
avoid Decoupling
just copy paste

create struct that is something new or unique
don't alias
don't abstract a concept like int

don't abstract or alias what the data IS

---> embed for behaviour not for state


do no start from Interfaces
and abstarction
start from the concrete

we decouple later
first implemente the problem

create a layer api
payer approach
3 layers at start

- primitive layer + unit tests [often unexported] (write to be testable - unit test) data in needs to be testable and so way out - give a set of data and get a set of data out
- lower layer + unit tests
- high level api (ease of use) (more integration type of tests)


data oriented api

primitive layer is not smart
solves the issue in the most correct simple way
not performant

use function first then method
a function is always more precise
because you need to explicitly pass all the parameters
with method when not written correctly
they can hide things


you don't want to have a struct that fails at runtime because it was not
initialised correctly

a function that only takes a struct is nothing more than a method
AVOID IT
so break the api if you need to expand a function
having 12 parameters is OK
don't abstract input
is gonna hurt with readability and impact

we should use pointer semantics with data

after you finish ask yourself:
what can come to this problem
understanding the business

the concrete implementation now is a guideline
to see what you can abstract

when you compose two interfaces
is common practice in go to merge the name of the
two interfaces

be careful with interfsaces
because they ask for any concrete piece of data that knows how to do something specific
a function

if you piece of data, even another interface, knows how to do it it's ok


* type assertion

runs at runtime
if it fails you have a panic

b := m.(bike)
where bike is an interface

one of the way this is used in the standard library
is to help override functions

so for example if in a function you ask for a reader and you have a default
implementation of the function
you could check if the type passed ALSO implement a function you
expect and if that happesn you can ignore your default
implementation and use that one instead

this only works if you pass the pointer to it
and not the value

it allows you do have a standard implementation
but allow the user to override it

* Interfaces advices

interfaces should describe behaviours

interfaces add the cost of indirection
and allocation

factory function
should return concrete type values
NEVER interfaces

SMELLS:
- the package declares an interface that matches the entire api of the concrete
- the interface is exported but the concrete type is not
- the factory function returns the interface value with the unexported concrete inside
- the interface can be removed and nothing changes for the user
- the interface is not decoupling the API from change


mocking a database is worthless

* Mocking

Don't use interface just to help testing

you can define your interface to test and mock
and use a library that has none
it's gonna work anyway



interfaces are good to decouple things
give program structure
encourage design by Composition


keep interfaces small
compose them as you need

* Errors

Handle when it happens
Exception hides the context
enough context to make an informed decisioin

recover or shut down

os.exit(code): fast
panic: gives you a stack trace

error is decoupled
interface error is built in

also errorString package
unexported in th errors packade
Error() return
whatever comes out of this function is logging only
it should not be parsed to understand

it has a constructor that return the error object

we always work with errors
at interface level

ADVICE
if there is a failure handle it and return
we can have multiple exit points
DON'T USE ELSE
no else, if and return if fail

not really one single exit point


NAKED SWITCH
with boolean login
so no if else if else
negative path always indented and on the return

you can declare a variable inside the if and the scope
of that variable is only there

nil is the zero value
for pointer and reference type
since error is an interface value
nil is an empty error interface
(no concrete value store inside the interface)


errors.New()

ErrXxxYyy

idiomatic efinition

you want the error variable
at the top of the source file
you are working on
and if it's global
in the file named like the package

switch a case and check the type that returned

use variable for error
to identify the concrete type that return
go give context to make informed decision

but don't pollute with too may string type
use string an vars instead

** Custom error types

an error variable won't be enough at this point

type UnmarshallTypeError struct

as an example

all the fields of the custom error type should be
in the logggin line
or what is the point

empty interface as second parameters?????
DON'T use it to write generic
use it only form
- pass data around that can be hidden with no problem
- or use the reflect type (use for model validation) - l

rv.Kind()
reflect.ValueOf()

reflect.Ptr

go gives special mechanism

switch e := err.(type) # type is a keyword

case *xyz
case *dbd

type assertion give you a copy of what is there?????

beware because this reduce decoupling

** behaviour as context

use custom error type but stay decoupled

e.Temporary() method
errors can be all we need

however this is very coupled
if you change the concrete type
will be a cascading changes issue

type OpError
naming conventio for custom error type
they end in Error

they all have Error implementaioin using the pointer semantic

if your custome error type
can have at leave

unexported with unexported error field
you can't type assert to the concrete
so you are available to change things in the future

- temporary
- timeout
- not found
- not authorized

don't export the type
fix temporary to be more accurate

this code doesn't change if we change the implementation
of the method

json package have custom error type
they need to be exported
because ????? they have to???? why???

unexported with unexported error field
use method instead

** whao

if you in a fuction say that you retunr a value type
of an error and retunr nil
the returned value is nil BUT have a type so is not nil!!!

if you used the error interface it would have been connect
but if you use the custom type it won't work!!!
wao
is a mess

always return the error type
not a custom type

if you use struct don't use value semantic??
don't use value semantic with struct
because beware with equality
interface values are values
if you compare two interface value you are comapring
the interface values inside it
so if you use value sematinc

for example if they have two interfsace
are different interface
but have the same sting value inside

so when you use pointer semantic
this way when you compare
you compare the pointers
and they are never gonna be the same

* Logging consistency / Pattern

you can't separate error and logging
we write application that logs a lot of thing
to be able to find bugs when an error occurs
logging too much have a lot of costs

a lot of allocation on the heap

we need to balance signal to noise
if you log but never read or use

log errors with enough context to actualluy debug
the issue

day chaining error package????
consistent way to apply error handling
and Logging

who manage the error have the responsability to log it

am I handling the error here or not?
if not wrap the error with context
and retgurn it

the lower you handle the error the better

errors.Wrap()

context:
- call stack context (where we are when this error occurred)
- user context

errors.Cause(err).(type)

the Cause function
knows how to unwind the error and get the root error
fmt.Println
%+v in the formatting the full stack trace and context
all of this get logged
%v only the user context

- [[https://blog.golang.org/go1.13-errors]]

* Packages

package oriented design find it link
design philosophy on packages link?? find it

basic unit of compilation

every folder in your repo
is a static library for go

ardanlabs/service

we build software
by separating it in static libraries

C a file so file
windows have dll
java has jar files
ruby has gem

in go every folder end up being a static library

packaging component level api

each dir should have program boundaries
like microservices

there is no concept of subpackages
al packages are built and compiler and laid out
for the compiler linker is all the same

be careful of exporting and exporting

two packages cannot import each other

- purpose (provide and not contain) - it's own type system
- usability
- portability

is ok to duplicate type system

each package needs to have a clear api
and the name should describe the intent

"coupling created constraints"
the more policy a package is, the less reusable it is

one way to do it is this:

kit project? as decoupled as possible
this packegs should not be logging
this foundational packages should not be Logging
and if one of this have goroutings that logs
you should ask for a handler function
so the user can implement in the handler funcrtion
and the packages use that. you don't nees interfaces for this
CONTRIBUTORS
LICENSE
README.md
cfg/
examples/
log/
pool/
tcp/
timezone/
udp/
web/

Application (project) can have multiple binaries
cmd/ : binaries of the application. one to many. all dir have a main.go. folder to organize
internal/ : business logic. reusable between binaries. files to organize
  internal/platform: for foundation packages not inside in kit.
vendors/

use the internal name
the compiler will protect you
from people using it outside

use dep for dependencies

    dep init
    dep ensure

kit would be a third party
you maintain a copy of all the source code
and sorce code and dependencies

now playing with vego

since importing/using an external package will create
binding be sure it's worth it
DON'T import a package just to use it's models
create your own models

in /internal
try not to make them import each other
keep them at the same level
try to minimize dependencies

every package we have inside of cmd
you

down is good up is bad
import down
import up bad

cmd
internal -> cannot import from cmd
vendor -> cannot import from cmd/internal

policy create coupling
kit, internal and platform should not be allowed to log,trace,etc
if needed use configuration changed at runtime
metrics/telemetry decouple

the application can set policy

kit and internal should not
wrapping error is a policy
panic is a policy

https://github.com/ardanlabs/gotraining

https://github.com/ardanlabs/service
