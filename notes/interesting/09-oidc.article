OIDC
|| Last update: 8 Jan 2020

* OAuth 2.0

- [[https://oauth.net/2/]]

    The normal process of generating these tokens is much the same as it is in
    OAuth 2.0:
    1. User hits the sign in button on the website,
    2. The website redirects them to the Identity Provider,
    3. Browser loads the Identity Provider login screen,
    4. User logs in using their username and password,
    5. Identity Provider redirects them back to the website with an authentication
    code in the query string,
    6. Browser loads website with the authentication code in query string,
    7. Website server exchanges the code for the ID token.

* OpenID Connect (OIDC)

- [[https://auth0.com/docs/protocols/openid-connect-protocol]]

    OpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0
    framework. It allows third-party applications to verify the identity of the
    end-user and to obtain basic user profile information. OIDC uses JSON web
    tokens (JWTs), which you can obtain using flows conforming to the OAuth 2.0
    specifications.
    Source: https://auth0.com/docs/protocols/openid-connect-protocol

    The explicit purpose of OIDC is to generate what is known as an id-token.
    This id-token takes the form of a JSON Web Token or JWT (pronounced jot).
    [...]
    This string actually comes in three parts, each Base64 encoded JSON. The
    first part provides metadata for the token. The second part provides the
    identity information, this is known as the payload. The third part is the
    signature, which is used to verify that the token was issued by a trusted
    party.
    Source: https://thenewstack.io/kubernetes-single-sign-one-less-identity/

OpenID Connect (OIDC) is an identity layer built on top of the OAuth 2.0 framework.

-> verify the identity of the end-user
-> obtain basic user profile information

    While OAuth 2.0 is about resource access and sharing, OIDC is about user
    authentication.
    [...]
    Each time you need to log in to a website using OIDC, you are redirected to
    your OpenID site where you log in, and then taken back to the website. For
    example, if you chose to sign in to Auth0 using your Google account then you
    used OIDC. Once you successfully authenticate with Google and authorize Auth0
    to access your information, Google sends information back to Auth0 about the
    user and the authentication performed. This information is returned in a JWT.
     You'll receive an access token and if requested, an ID token.
    Source: https://auth0.com/docs/protocols/openid-connect-protocol

** JSON Web Tokens (JWT)

- [[https://jwt.io/]]
- [[https://auth0.com/docs/tokens/json-web-tokens/json-web-token-claims]]

    JWTs contain claims, which are statements (such as name or email address)
    about an entity (typically, the user) and additional metadata.
    Source: https://auth0.com/docs/protocols/openid-connect-protocol

** Identity provider

    Dex?
    Auth0 -> OAuth2 identity provider (Google)

To use Auth0 as the identity provider, itself using G Suite as the final upstream
identity provider.

OpenID Connect Provider such as Keycloak, Google Identity Provider, Azure AD ...

- [[https://developers.google.com/identity/protocols/OpenIDConnect]]

** Using OIDC with k8s

- [[https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens]]

NOTE: You will need an OIDC provider like for example google.

OIDC is Kubernetes answer to Single Sign-On.

    Kubernetes itself does not provide any sort of login website for OIDC
    authentication. It only consumes the tokens once you have retrieved them
    from some other means.
    [...]
    [...] the third part of the token is a signature, every ID
    token generated by an OIDC provider comes signed with a cryptographic key
    (usually RS256, generated and rotated periodically by the provider). By
    providing Kubernetes with the URL of the OIDC provider, Kubernetes can
    retrieve the public half of this key and verify that the token was indeed
    signed by the OIDC provider. At this point, Kubernetes will accept the token
    and trust the token’s claim as to who the user is.
    [...]
    The id-token once generated cannot be revoked. Much like issuing certificates
    for auth, the id-token has an expiry time and it will authenticate the user
    until that time comes. This means the tokens are often only issued for 1 hour,
    but some providers do support requests for refresh tokens. Refresh tokens
    can be used (often indefinitely) to grant a new id-token and continue usage
    of the service.
    Source: https://thenewstack.io/kubernetes-single-sign-one-less-identity/

K8s api server have some flags to define how to use the OIDC provider.

    --oidc-issuer-url=https://auth.example.com/dex
    # The client ID configured. Kubernetes will compare this to the `aud` field
    # in any bearer token before accepting it.
    --oidc-client-id=kubernetes
    # If with with TLS, add the CA cert to initiate trust
    --oidc-ca-file=/etc/kubernetes/ssl/dex-ca.pem
    # The claim field to identify users. For us this means users are granted the username
    # or email address
    --oidc-username-claim=email

When presented with an id-token generated, Kubernetes can verify the token and
use the token to authenticate the user.

    Dex (and other OIDC providers) uses a whitelist of redirectURIs to verify
    the identity of the software requesting the user’s token. By providing the
    redirectURI in the initial request to Dex, Dex can issue the id-token to one
    of its known clients (in this case with ID kubernetes) and will expect the
    matching pre-shared secret to be presented by the client software during the
    token exchange phase of the authentication flow. This ensures trust and
    prevents man in the middle attacks.
    Source: https://thenewstack.io/single-sign-kubernetes-command-line-experience/

Then configuration can be added to the kubeconfig:

    - name: joel.speed@pusher.com
    user:
    auth-provider:
    config:
    client-id: kubernetes
    client-secret: &lt;SOME_SUPER_SECRET_STRING&gt; # Pre-shared client auth
    id-token: &lt;TOKEN_RETRIEVED_FROM_THE_EXAMPLE_APP&gt;
    idp-issuer-url: https://auth.example.com/dex
    refresh-token: &lt;REFRESH_TOKEN_RETRIEVED_FROM_THE_EXAMPLE_APP&gt;
    name: oidc
    Source: https://thenewstack.io/single-sign-kubernetes-command-line-experience/

** KOPS settings

- [[https://medium.com/@int128/kubectl-with-openid-connect-43120b451672]]

* DEX

- [[https://github.com/dexidp/dex]]

Dex is configured to authenticate users with their Google GSuite accounts.
It acts as a proxy to the authentication flow.
We can revoke tokens with Dex

    Dex acts as a middleman in the authentication chain. It becomes the Identify Provider and issuer of ID tokens for Kubernetes but does not itself have any sense of identity. Instead, it allows you to configure an upstream Identity Provider to provide the users’ identity.
    As well as any OIDC provider, Dex supports sourcing user information from GitHub, GitLab, SAML, LDAP and Microsoft. Its provider plugins greatly increase the potential for integrating with your existing user management system.
    Dex also handles refresh tokens for users. When a user logs in to Dex they may be granted an id-token and a refresh token. Programs such as kubectl can use these refresh tokens to re-authenticate the user when the id-token expires. Since these tokens are issued by Dex, this allows you to stop a particular user refreshing by revoking their refresh token. This is really useful in the case of a lost laptop or phone.

Dex spun out of red hat after the merge.

* Vouch

- [[https://github.com/vouch/vouch-proxy]]
- [[https://openresty.org/en/]]

** Tools? - TO BE TESTED AND CLEANED

- [[https://github.com/int128/kubelogin]]
- [[https://medium.com/@int128/kubectl-with-openid-connect-43120b451672]]

    # Homebrew
    brew install int128/kubelogin/kubelogin
    # or
    # Krew
    kubectl krew install oidc-login

and:

    users:
    - name: keycloak
      user:
        exec:
          apiVersion: client.authentication.k8s.io/v1beta1
          command: kubectl
          args:
          - oidc-login
          - get-token
          - --oidc-issuer-url=https://issuer.example.com
          - --oidc-client-id=YOUR_CLIENT_ID
          - --oidc-client-secret=YOUR_CLIENT_SECRET

You will need to link the role:

    kind: ClusterRoleBinding
    apiVersion: rbac.authorization.k8s.io/v1
    metadata:
      name: oidc-admin-binding
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: cluster-admin
    subjects:
    - kind: User
      name: https://keycloak.example.com/auth/realms/hello#874c4a74-faf3-45a0-bcfe-9ddf4fb802ea

* Question

QUESTION: Hydra??
QUESTION: Can I bypass els-auth for directly use google?
QUESTION: Token refresh?
QUESTIION: https://github.com/oauth2-proxy/oauth2-proxy IS THIS LIKE VOUCH?
QUESTIION: https://github.com/micahhausler/k8s-oidc-helper

* Re/Sources

- [[https://thenewstack.io/kubernetes-single-sign-one-less-identity/]] - Mar 2018
- [[https://thenewstack.io/single-sign-kubernetes-command-line-experience/]] - Mar 2018
- [[https://www.youtube.com/watch?v=P3q_5qHrea4]]
