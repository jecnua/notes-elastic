Helm 2
|| Last update: 1 Aug 2019

* Intro

- [[https://helm.sh/]]
- [[https://helm.sh/docs/]]
- [[https://helm.sh/docs/chart_best_practices/#the-chart-best-practices-guide]]

Helm is a tool to allow the reuse and composability of releases in k8s.
It bundles yaml files in charts and using this charts will release the
services in kubernetes. Helm charts are build on top of k8s resources.
It have a powerful mechanism of templating (go) that allow the injection of
values at deployment time (otherwise will use the defaults).

Enable compositions via dependencies (it can use other charts).

* History

Originated by Deis in 2015 and donated to the CNCF in 2018.

** Why

You can always do a:

  kubectl apply -f dir/*

So why use helm? helm has the concept of _releases_.
Releases are stored as _configMaps_ inside kubernetes and are made by
the totality of all the resources applied to kubernetes.

- PRO: reuse code, templating, delete unused resources
- CON: lose the versions

kubectl we apply don't delete anything that's not present anymore.
If you in the latest version of your YAML do no have a resource
anymore, it will leave it there. HELM instead removes it.

* Concepts

- [[https://www.slideshare.net/djablonski/steering-the-course-with-helm]]

.image images/helm-infra.jpg
.caption Source: https://www.ibm.com/cloud/garage/content/course/helm-fundamentals/1

- Chart
- Repository
- Release
- Template

** Charts

They consist of a YAML configuration files and templates that are rendered into
Kubernetes manifest files. It a wrapping of resources that bundles together:

- metadata
- templates
- default values
- docs

You can generate a skeleton of a chart with the command:

    helm create

Charts uses semantic versioning.

The default value files are stored in the _values.yaml_ in the root of the chart.
They can be overridden later.

Charts are stored in a registry called *helm*museum*.

** Repositories

- [[https://github.com/helm/charts/tree/master/stable]]
- [[https://chartmuseum.com/]]
- [[https://www.cncf.io/wp-content/uploads/2018/08/Continuous-Delivery-for-Kubernetes-Apps-with-Helm-and-ChartMuseum.pdf]] - Aug 2018

A _repositories_ is a web server with an index.yaml
You can use git repository.
Charts can be packaged into chart archives (a .tar.gz) packaged version.
These packaged charts can also be automatically downloaded and installed from
chart repositories or repos.

You can create your own chart repository with [[https://chartmuseum.com/][chartmuseum]].

Other interesting repositories are:

- https://github.com/helm/charts/tree/master/incubator
- https://bitnami.com/stacks/helm

** Release

A _release_ is an instance of a chart that is loaded in k8s.
Information about releases are stored as config maps.

    helm install <stable>
    #
    helm install stable/prometheus

When you run:

    helm upgrade

It will change the release to a new release.

** Template

- [[https://helm.sh/docs/chart_template_guide/]]

A k8s configuration file mixed with go/spring templates.

* Installation

HELM is an executable and can be downloaded from github.

** Linux

This example will download the binary in _/tmp_:

  cd /tmp
  wget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gz
  tar xvf helm-v2.13.1-linux-amd64.tar.gz
  cd linux-amd64/
  ./helm --help
  # Then put it in your path
  # sudo cp helm ~/bin/helm

** Mac

With brew:

    brew install kubernetes-helm

* Usage

** Installation

- [[https://helm.sh/docs/helm/#helm-init]]

Helm init will install a *tiller* application in your k8s cluster.

  helm init --wait

When your cluster have RBAC enabled you will first need to take care of that.

- [[https://github.com/helm/helm/blob/master/docs/rbac.md#tiller-and-role-based-access-control]]

    apiVersion: v1
    kind: ServiceAccount
    metadata:
      name: tiller
      namespace: kube-system
    ---
    apiVersion: rbac.authorization.k8s.io/v1
    kind: ClusterRoleBinding
    metadata:
      name: tiller
    roleRef:
      apiGroup: rbac.authorization.k8s.io
      kind: ClusterRole
      name: cluster-admin
    subjects:
      - kind: ServiceAccount
        name: tiller
        namespace: kube-system
    ###
    $ kubectl create -f rbac-config.yaml
    $ helm init --service-account tiller --history-max 200

** Other commands

Then you can use it.

  helm repo update
  helm update

Create your own repo with charts

    helm search <-- all thing

If you want to just see what he is going to do:

    helm install <chart> --debug --dry-run

Is a good idea to give a name to releases. If you don't it will give it a
random name.

    helm install --name prometheus stable/prometheus --debug --dry-run

The debug flag will output the yaml that will actually be used and applied to
the cluster.

- [[https://helm.sh/docs/helm/#helm-template]]

    helm delete --purge <name>

You can rollback to another release.

** Advices

One trick to autodeploy every time a config map changes is to add:

    spec:
      template:
        metadata:
          annotations:
            checksum/config: {{ include (print $.Template.BasePath "/configmap.yaml") . | sha256sum }}

or use:

    helm upgrade --recreate-pods

* Templating

Helm chart files can make use of the go templating language.
For example, to access data in the _value_file_ of a chart, you can use:

    {{ .Values.service.name }}

Helm is namespace aware. You don't need to add the namespace in your charts
since it will injected automatically depending on what you use to call the
install command:

    helm install <name> --name test --namespace <namespace_that_will_be_used>

** Flow control

- [[https://github.com/helm/helm/blob/master/docs/chart_template_guide/control_structures.md]]

There are way to impose flow control:

- If/else
- with
- range
- variables (in range)
- nested templates
- files inside a template
- glob patterns and encoding

However inside a loop, you won't have access to the global scope.
To avoid this issue you can save the scope in a variable before starting the loop.
For example:

- [[https://github.com/helm/helm/issues/1311#issuecomment-252536380]]

    {{ $myChartName := "FooBar" }}
     {{- range $key, $value := .Values.secrets }}
     - name: $key
       valueFrom:
         secretKeyRef:
           name: {{ $myChartName }}
           key: $value
     {{- end }}
    Source: https://github.com/helm/helm/issues/3684#issuecomment-373195562

** Concatenate strings

- [[https://stackoverflow.com/a/48451109]]

You can print a concatenated string with _printf_:

    {{ define "makeServiceNamespace" }}
        {{- if .Values.serviceTag }}
        {{- printf "%s-%s" .Values.serviceNamespace .Values.serviceTag -}}
        {{- else }}
        {{- print .Values.serviceNamespace }}
        {{- end }}
    {{- end }}

** Helper files

There can be helpers file. The all begin with _ and they WON'T be rendered.
They contain helpers can are reused in multiple places inside the charts.
By conventions they end in _.tpl_.

* Overriding values

THE OVERRIDE ORDER IS CLEARLY DEFINED

    These values can be overridden by writing your own YAML file and using it when
    running helm install, or by setting options individually on the command line
    with the --set flag. You only need to specify those values that you want to
    change from the defaults.
    Source: https://www.digitalocean.com/community/tutorials/an-introduction-to-helm-the-package-manager-for-kubernetes

From command line (imperative) will look something like this:

    helm upgrade <name> --set replicaCount=3,image=xyz <chartname>

Best way you define a new value file and use that to override the default value
since it's declarative.

    helm install test --values overrides.yaml

You can see all the values defines in a chart with:

    helm inspect values <chart_name>

* Dependencies

Dependencies are defined in the _requirements.yaml_ file.
They follow the following syntax.

    dependencies:
    - name: aname
      version: ^0.1.0
      repository: "@xyz"

*NOTE*: In helm 3 the _requirements_ file will be merged into the main Chart.yaml

* Create a new chart

To create a new chart use:

    helm create <name>

It will create a new directory with the following files inside:

    .
    ├── Chart.yaml
    ├── charts
    ├── templates
    │   ├── NOTES.txt
    │   ├── _helpers.tpl
    │   ├── deployment.yaml
    │   ├── ingress.yaml
    │   ├── service.yaml
    │   └── tests
    │       └── test-connection.yaml
    └── values.yaml

To apply a local chart, point to the path:

      helm install <path>
      # for example from the
      helm install mychart
      # or from inside the chart
      helm install .

You can see all the generated yaml before applying:

      helm template mytest | less

** Hooks

- [[https://helm.sh/docs/developing_charts/#hooks]]

Helm have hook to allow a better release process:

- pre-install
- pre-upgrade
- post-upgrade
- post-install

- pre-delete
- pre-rollback
- post-rollback
- post-delete

- crd-install

* Security

Options to enforce access control with Helm:

- Deploy tiller per namespace with RBAC and client certs
- Use: helm --template test | kubectl -f -
- Wait for Helm 3

* Helm 3

- [[https://sweetcode.io/a-first-look-at-the-helm-3-plan/]]
- [[https://github.com/helm/helm/releases/tag/v3.0.0-alpha.1]] - 15 May 2019

Moving to Lua.

* Re/Sources

- GOOD SLIDES - [[https://speakerdeck.com/devopsgatheringio/04-helm-build-fashionable-container-systems-with-kubernetes-by-peter-rossbach]] - 12 Mar 2019
- [[https://medium.com/dailymotion/deploying-apps-on-multiple-kubernetes-clusters-with-helm-19ee2b06179e]] - 14 Jun 2019
- [[https://www.digitalocean.com/community/tutorials/an-introduction-to-helm-the-package-manager-for-kubernetes]] - 6 August 2018
- [[https://github.com/helm/helm/issues/1569#issuecomment-261662068]]
