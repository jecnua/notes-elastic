Best practices
|| Last update: 22 Aug 2017

* Tags

- [[https://aws.amazon.com/premiumsupport/knowledge-center/ec2-resource-tags/][Best practices]]

Everywhere terraform allow to have tags, add them.
At least try to have:

- Name
- Description (optional)
- TfCodePath: Follows
- TfModuleName (only if a module): The module name
- Env: The environment

** Terraform code reference

Tag the code you refer to in terraform (ALWAYS):

    TfCodePath   = "${join("/",slice(split("/", path.cwd),
    length(split("/", path.cwd)) - 3, length(split("/", path.cwd))))}"

The other are not very useful:

    TfCodePath   = "${join("/",slice(split("/", path.cwd),
    length(split("/", path.cwd)) - 3, length(split("/", path.cwd))))}"
    TfPathCwd    = "${path.cwd}"
    TfPathModule = "${path.module}"
    TfPathRoot   = "${path.root}"

Will result in:

    tags.TfCodePath:   "my-terraform-repo/development/my-module"
    tags.TfPathCwd:    "/Users/fabrizio.sabatini/git/my-terraform-repo/development/my-module"
    tags.TfPathModule: "/Users/fabrizio.sabatini/git/my-terraform-repo/development/my-module/
      .terraform/modules/a3eda4daf706c9875a23dc8a678dd035"
    tags.TfPathRoot:   "/Users/fabrizio.sabatini/git/my-terraform-repo/development/my-module"

** Name and/or Description

Human readable.

* Security groups

** Explicit names

To avoid to look like:

    name: "terraform-006466ad9f29d55036287b004f"

Don't use name prefix!!! They limit to too little characters.
Set *names*:

    name   = "${substr(format("app-ag-alb-sg-%s-%s", var.environment, random_id.random_gen.dec), 0, 32)}"

And 32 is the limit.

** Make them injectable

All sg should have NO inline definition. When inside a module the id should be returned to allow *injection* if needed.

* Autoscaling groups

** Explicit names

AG and LC should have explict names:

    name = "${substr(format("example-api-lc-%s-%s", var.environment, random_id.random_gen.dec), 0, 32)}"

** Enable metrics

- [[https://aws.amazon.com/about-aws/whats-new/2016/08/free-auto-scaling-group-metrics-with-graphs/][https://aws.amazon.com/about-aws/whats-new/2016/08/free-auto-scaling-group-metrics-with-graphs/]]

Activate on all auto-scaling group because they are [[https://docs.aws.amazon.com/cli/latest/reference/autoscaling/enable-metrics-collection.html][not by default]]:

    enabled_metrics = [
      "GroupMinSize",
      "GroupMaxSize",
      "GroupDesiredCapacity",
      "GroupInServiceInstances",
      "GroupPendingInstances",
      "GroupStandbyInstances",
      "GroupTerminatingInstances",
      "GroupTotalInstances",
    ]

** Notifications

All Autoscaling Groups should notify in case of events.
However, a SNS queue should *never be created INSIDE a module*.
Instead, pass it to the module as a variable.

    variable "sns_topic_notifications" {
      type        = "string"
      Description = "The SNS topic to use when the system autoscale. If empty no notification will be sent"
      default     = ""
    }

And be optional if alerting or not:

    resource "aws_autoscaling_notification" "mod_asg_notification" {
      count     = "${var.sns_topic_notifications == "" ? 0 : 1}"
      topic_arn = "${var.sns_topic_notifications}"

      group_names = [
        "${aws_autoscaling_group.ag_name.name}",
      ]

      notifications = [
        "autoscaling:EC2_INSTANCE_LAUNCH",
        "autoscaling:EC2_INSTANCE_LAUNCH_ERROR",
        "autoscaling:EC2_INSTANCE_TERMINATE",
        "autoscaling:EC2_INSTANCE_TERMINATE_ERROR",
      ]
    }

* ELB/ALB

** Naming conventions

- int-elb
- ext-elb

** ALB only

*** Span a subnet for each AZ

They should be defined *outside* the module and point to the module you are going
to use.

*** Limit ALB name to 32 chars

*** Limit Target group names to 32 chars

** ELB only: for autoscaling groups healthchecks

** Explicit names

** Logs on s3

*** No external access

- Should have only default listener 80 and no SSL or other access

* AMI

Every module should allow an AMI id to be passed as parameter.
However, if nothing is passed, the module should fetch the latest AMI on AWS filtered by a specic regex.
Passing an AMI should override this dynamic search.

    variable "ami_id" {
      Description = "The id of the AMI to use. If empty, the LATEST will be used."
      default     = ""
    }

Example of dynamic fetching:

    data "aws_ami" "ami_dynamic" {
      most_recent = true
      owners      = ["${var.ami_owner}"] # For example Canonical ID
      filter {
        name   = "name"
        values = ["${var.ami_name_filter_regex}"]
      }
      filter {
        name   = "virtualization-type"
        values = ["hvm"]
      }
      name_regex = "${var.ami_name_regex}"
    }

When using a resource that need an AMI:

    image_id = "${var.ami_id != "" ? var.ami_id : data.aws_ami.ubuntu.id}"

On a module level:

    module "k8s" {
      source            = "xxx"
      [...]
      ami_id_worker     = "ami-f0768de6"
    }

* Variables

All variable should have:

- type
- Description

And optionally default.

* Modules

** Never create DNS

*NEVER* create DNS entries inside a module!

You can check for any such reference in the files.

    TOTAL=`find . -name "*.tf" | xargs cat | grep 'resource "aws_route53_record"' | wc -l`
    if [[ $TOTAL -ne 0 ]]
    then
      printf "$RED Failed! Found $TOTAL occurrence/s $NC \n"
      let N_FAILED=N_FAILED+1
    else
      echo "ALL GOOD"
      let N_SUCCESS=N_SUCCESS+1
    fi

** Make thinks optional

Use count=0.

** Files

They should have the following files:

- 00-backend_and_provider.tf
- 00-remote-states.tf
- 00-variables.tf
- 00-variables_default.tf (only for modules)
- 00-variables_required_inputs.tf (only for modules)
- 99-output.tf
- README
- CHANGELOG (only for modules)
- params.md (generated)
- terraform.tfvars

*** 00-backend_and_provider.tf

This is an example:

    terraform {
      # The configuration for this backend will be filled in by Terragrunt
      backend          "s3"             {}
      required_version = ">= 0.10.8"
    }

    provider "terraform" {
      version = "~> 1.0"
    }

    provider "aws" {
      region     = "${var.network_region}"
      access_key = "${var.access_key}"
      secret_key = "${var.secret_key}"
      version    = "~> 1.1"
    }

    provider "random" {
      version = "~> 1.0"
    }

    provider "template" {
      version = "~> 1.0"
    }

    variable "access_key" {
      description = "Read at run-time"
      type        = "string"
    }

    variable "secret_key" {
      description = "Read at run-time"
      type        = "string"
    }

*** 00-remote-states.tf

If needed: It can host the reference to remote states.

    data "terraform_remote_state" "lb_network_global" {
      backend = "s3"

      config {
        bucket = "my-terraform-state"
        key    = "global/lb-network/terraform.tfstate"
        region = "us-east-1"
      }
    }

* Tips and tricks

    terraform show

** Check all terraform.tfvars

    find . -name "terraform.tfvars" | xargs cat
    find . -name "*.tfvars" | xargs cat

They should only have:

    terragrunt = {
      include {
        path = "${find_in_parent_folders()}"
      }
    }

** Check there is no terragrunt file

    find . -name ".terragrunt" | xargs cat

** Don't use uuid to create names

If you do this:

    name = "${substr(format("myelb-int-80-%s", uuid()), 0, 32)}"

You will need to put:

    lifecycle {
      [...]
      ignore_changes        = ["name"]
    }

** Always generate params file

On mac:

    brew install terraform-docs
    brew list | grep terraform

And then:

    terraform-docs md `pwd` > `pwd`/params.md

** Atom only

Some plugins:

    apm list | grep terraform
    ├── language-terraform
    ├── linter-terraform-syntax
    ├── terraform-fmt

** Functions

Avoid checks like this:

    count = "${var.num_nodes_for_app == 0 ? 0 : 1}"

It's useful when you want to parametrise things like AG or CN.
But instead of:

    == 0 ? 0 : 1

Use [[https://www.terraform.io/docs/configuration/interpolation.html#signum-int-][signum]]:

    count = "${signum(var.num_nodes_for_app)}"

* Workflow

** Create a new environment

The in _01-main_blue.tf_:

    module "mymodule_01" {
    [...]
    }
