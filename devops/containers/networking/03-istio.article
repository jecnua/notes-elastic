Istio
|| Last update: 1 Oct 2018

* Intro

- [[https://istio.io][Istio website]]
- [[https://github.com/istio/istio][Istio github]]

Istio is not a k8s technology and can work with other orchestrators.

The goal of a control plane is to set policy that will eventually be enacted by the data plane.
Provides policy and configuration for all of the running data planes in the mesh.
Does not touch any packets/requests in the system.

- Data planes: Linkerd, NGINX, HAProxy, [[https://www.envoyproxy.io/][Envoy]], Traefik
- Control planes: Istio, Nelson, SmartStack

Linkerd one of the first (early 2016 - [[https://buoyant.io/2016/02/18/linkerd-twitter-style-operability-for-microservices/]]).
Envoy 6 months later ([[https://eng.lyft.com/announcing-envoy-c-l7-proxy-and-communication-bus-92520b6c8191]]) (but in prod in left since 2015).

    The network should be transparent to applications. When network and application
    problems do occur it should be easy to determine the source of the problem.
    — Envoy

Istio announced in May 2017. Default proxy of Istio is Envoy.
Istio has garnered a lot of excitement, and other data planes have begun
integrations as a replacement for Envoy (both Linkerd and NGINX have
demonstrated Istio integration)

Nelson and SmartStack help further illustrate the control plane vs. data plane
divide. Nelson uses Envoy as its proxy and builds a robust service mesh control
plane around the HashiCorp stack (i.e. Nomad, etc.). SmartStack was perhaps
the first of the new wave of service meshes. SmartStack forms a control
plane around HAProxy or NGINX

* What is a service mesh

- [[https://en.wikipedia.org/wiki/Mesh_networking]]
- [[https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/]]

    A service mesh is a dedicated infrastructure layer for handling
    service-to-service communication. It’s responsible for the reliable
    delivery of requests through the complex topology of services that
    comprise a modern, cloud native application. In practice, the service
    mesh is typically implemented as an array of lightweight network proxies
    that are deployed alongside application code, without the application
    needing to be aware.
    - https://buoyant.io/2017/04/25/whats-a-service-mesh-and-why-do-i-need-one/

.image images/service_mesh_color.png

The control plane enables the proxies to implement things like access control
and metrics collection, which requires cooperation:

Two benefits of this approach are already evident to me. First, not having to
write custom software to deal with what are ultimately commodity code for
microservices architecture will allow for many smaller organisations to enjoy
features previously only available to large enterprises, creating all sorts of
interesting use cases. The second one is that this architecture might allow us
to finally realise the dream of using the best tool/language for the job without
worrying about the availability of libraries and patterns for every single
platform.

.image images/service_mesh_black.png

.image images/service_mesh_generic.png

* What is Istio

Istio is a distribuited control plane to configure envoy system records for
service mesh.

.image images/istio_arch.svg _ 750
.caption Source: [[https://istio.io/]]

.image images/all_istio.png _ 750
.caption Source: [[https://www.youtube.com/watch?v=IfPt3z6UAGw][JavaDay UA 2017: 8 Steps to Become Awesome with Kubernetes (Burr Sutter)]]

Istio is a:

- Network mesh
- Cluster wide policy enforcer (for access control)
- In depth telemetry exporter

Is very useful to help connect _legacy_ and _distribuited_. It helps to separate:

- Run-time
- Configuration
- Context

Like:

- Routes
- Firewall routes
- Security context

* Installing Istio

** Requirements

Requires kubernetes *1.7.4+*

Istio now uses CRD (CustomResourceDefinitions) so it needs k8s 1.7.4+.

You can install it manually but is not covered by this page.

** Helm

- [[https://github.com/kubernetes/charts/tree/master/incubator/istio]]
- [[https://istio.io/docs/setup/kubernetes/sidecar-injection.html#automatic-sidecar-injection]]

Helm is a two step installation.

    #https://github.com/kubernetes/charts/blob/master/incubator/istio/templates/service-account/initializer.yaml
    helm install --name istio \
      incubator/istio \
      --devel \
      --namespace istio-system \
      --set istio.release=0.4.0,initializer.enabled=true,rbac.install=true
    helm upgrade istio incubator/istio --devel --reuse-values --set istio.install=true

If you are not on AWS the update can be:

    helm upgrade istio incubator/istio --devel --reuse-values --set istio.install=true --set ingress.service.type=NodePort

THIS????

    kubectl create clusterrolebinding add-on-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:default
    helm install --name istio incubator/istio --devel --namespace istio-system --set istio.release=0.4.0,initializer.enabled=true

*** Possible errors

    Error: UPGRADE FAILED: apiVersion "admissionregistration.k8s.io/v1alpha1"
    in istio/templates/initializer/initializer.yaml is not available

In case you don't have the initialiser (alpha) enabled.

*** How to test it worked

    cd Downloads/istio-0.4.0/
    kubectl get deployment sleep -o yaml
    kubectl apply -f samples/sleep/sleep.yaml
    kubectl get pods
    echo $(kubectl get deployment sleep -o jsonpath='{.metadata.annotations.sidecar\.istio\.io\/status}')

* Structure

The structure is very similar to kubernetes. It has a concept of control plane.

- envoy (data plane)
- pilot
- mixer

istio is a unified control plane.

** Envoy

.image images/envoy.svg _ 750
.caption Source: [[https://istio.io/]]

- [[https://www.envoyproxy.io/]]

    Envoy is a self contained process that is designed to run alongside every
    application server. All of the Envoys form a transparent communication mesh in
    which each application sends and receives messages to and from localhost and
    is unaware of the network topology.

Envoy is a distruited data plane.
Data planes by themselves do nothing. They need to be configured by something larger.
Other example of data plane are:Linkerd, NGINX, HAProxy.

Service mesh data plane (via sidecar):

- service discovery
- health checking
- routing
- load balancing
- authentication and authorisation
- observability (statistic, trading and logging)

While _haproxy_ and _nginx_ are *config*file*hub*, envoy is made to receive
orders from pilot. The data plane is responsible for conditionally translating,
forwarding, and observing every network packet that flows to and from a service instance.

Envoy lives in a sidecar in each pod. There are two ways to configure it:

- use a tool to inject
- using an initialiser (kubernetes)

.image images/sidecar.png _ 750
.caption Source: [[https://medium.com/@mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc]]

The initialiser works by telling k8s that before you run a pod, inject the stuff.
The user doesn't need to know. When _things_ change, envoy changes.

envoy is both a _sidecar_ for all the data and serve as _ingress_ and _egress_.

Envoy knows of all the other envoys and so on.

*** How does it work

Sidecars in this case are network proxy.

All network traffic flows via it’s local sidecar proxy to the appropriate destination.
Service instances are not aware of the network at large and only knows about it’s local proxy.
The distributed system has been abstracted away from the service programmer.

** Pilot

.image images/pilot.svg _ 750
.caption Source: [[https://istio.io/]]

_Envoy_ has been fully rewritten in C - is connected to a distribuited system and
highly dinamically configurable.

Pilot is a system of record for the server mesh. All envoy receive the same
configuration and dinamically changes the configs for envoy.

Pilot is also abstracted from the underlying platform and use adpters to
communicate with the platform. istio has a kubernetes adapter but IS NOT made for
k8s.

.image images/control_plane.png _ 750
.caption Source: [[https://medium.com/@mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc]]

istio and translate in ingress and other network rules is something Istio can
understand.

Plus, it has a plugging api for routing and other stuff like:
- black hole
- ingestion

** Mixer

.image images/mixer.svg _ 250
.caption Source: [[https://istio.io/]]

Is the policy engine: telemetry, billing, quota and so on.

If you want an API gateway you usually will put on something like Kong. *Mixer*
is the component of Istio that takes decisions.

Mixer has plugins for tracing, prometeus and much more.

Unfortunately (as of 2.9), you still need to fork, build and maintain the code
yourself if you want to add a new functionality to mixer. They are working on modularity.

There is a lot of metadata that is aggregated and send it to mixer so you can do
rules and so on.

All expressed under the hood as CRDs.

* Capabilities

.image images/capabilities.png

** Mutual TLS

.image images/mutual_tls.png _ 800
.caption Source: [[https://www.youtube.com/watch?v=wq1nlJNvy1w][Setting Sail with Istio [B] - Lachlan Evenson, Microsoft]]

Before this was before based on top of vault, but is was clunky and not working
well.

- it uses k8s enabled stuff
- all service communication and tsl
- all communication is encrypted
- and lifecycle of certificates is managed by istio

** Deployments

Istio can give you out of the box tools like _canary_deployments_.
Sending a percentage of the traffic to a new version of your service.

K8S already have _rolling_deployments_ under the cover, but what if you want to filter traffic by:

- tokens
- headers
- network

and much more, Istio can help you.

** Access control

k8s have _network_policies_ but they have problems:

- They are op focused (and devs usually don't do them)
- They are more cluster side
- Difficult to write

** Ingress

Istio doesn't work with nginx ingress containers (http1 problem?).

Some people replaced nginx with Traefik (very low footprint)

** Egress

While k8s have ingresses, it does not have egress. *Egress* is a new way to funnel all
the traffic exiting my cluster through a deployment group.

As a DEV they know if an application needs or not external access, and this allow them to
_close_ egress access.

** Telemetry

Istio will give you access to app telemetry without having to instrument the
application itself. You can add and have this metrics without having to go
through the DEVs.

** Tracing

Tracing is not about debugging you application, is about debugging the _process_.

Debugging is hard in k8s:

- kubectl proxy
- run a debug pod
- inject debug (sidecar) containers
- mTLS is hard!

Istio will inject headers, but you need to *forward* them in the code.

    NO FRAMEWORK WILL SAVE YOU FROM BAD CODE

** API gateway

    API gateway ~= Ingress

* Technologies

- consul support
- opentracing
- vault support
- nginx
- prometheus
- spify ???? (secrets?) identy to application

sits in datapath, map events

* Istio and Rancher

It will probably be integrated in Rancher soon.

    # From a QA in October 2017
    Q: Any plans on supporting Istio in Rancher 2.0?
    A: :)

* Usage

How do you make it so that is applies?
It uses sidecars.
You build a config pushed on every node.

You don't need to instrument your code
Attach functionality to the system

attach sidecar without changing the yaml
add a second container
grab info from the data plane

add zipkin so you have tracing

** Option 1: Initialisers

*From*v0.2*only*

For the newer versions you can use [[https://kubernetes.io/docs/admin/extensible-admission-controllers/#enable-initializers-alpha-feature][_initialisers_]]
to avoid having to inject yaml with istioctl all the time. _initialisers_ are pretty new to k8s so you may
need to abilitate them via the alpha API.

_initialisers_ allow you to have *automatic*sidecar*injection* in all your pods.

    before ???

** Option 2: The old way

    istioctl kube-inject -f

* New notes from meetup 1 October 2018 - NOTES AFTER THIS POINTS NEED TO BE REVIEWED

istio is a network sandbox
will solve load balancing, observability, in service security

every node have a persistent tcp connection with every other node
envoy use ip tables to send traffic to itself via network namespace

pod is the smalle security boundary
so that there is a plaintext communication between envoy and the app is not a problme
if the pod is compromised we consider the app compromised

the mtls is guaranteed because both ssl ase singed from the same CA (citadel)
the secure name is extracted from the cert
policy decision from the guaranteed name
- secure naming

ingress and egress procy terminate ssl connection coming in or out


in citadel is probably bets practice to generate a new cert inside the clusterrole
id btter than using an external CA

loocal loopback bypass
can speak to iteself before for error leaking in the meshes

mutating webhook

proxy_init how the network namespace is configured

initi containers
NET_ADMIN
likecly root for attack

the init container just do the change then stop
and then the normal contanier is leaved without the prividelge to do so
proxy_init

ssh is not managed by istio
ipv6 is dropped or you can do what you want

envoy have no prividelge to change the namespace

istiocl proxy-xxx cluster xxx

self signed CA is usually but but not in this case
in an isolted system is superior then a external CA
this is because even if you compromise the cluster CA
you need to compromise the root of the host hosting it

usually CA are managed very badly by a company

istio is zero trust Deployments
trust nothing, validate everything
essence of secure naming system in istiocle

end to end mapping of names ???
istio generate this secure name

istio citadel is a scratch container
highest citadel is the best security up to know
is impossible to attach with remote code execution
because there  is nothing there at all

istio citadel is run as root
with sysdig you can see that is run a root

citadel is watching the k8s api
pulls any secret
if not generate it's own CA
creating it's own PK
that takes a service acocunt????
the security name is based on this???
sensible of things are anrchitected.

watch on service account
spiffe foundament of the secure service
and this is encoded in the TSL certificate
spiffy baded on

** spiffe

set of opensource standarn
trust domain and workload identifier

istio does not use spiffe
as spiffe is designed kno
in the furutre istio will use xxx to identidy something unique
on the service and encode that in the ssh cert

spiffe verified identity protocol

generate the spiffe name????? is this in the furutre

issuing and rotating ssl is a pain
close to admin role for citadel

RBAC for service role is level 4?????
you can have per service rbac

envoy ocnfiguration is immutable
and new request have a new config?????

end user authentication
allow to use them for delegate request

in the future they can propagate credential in more than one op

ingress allow a chockepoint
require full reload to allow a cert to be loaded
and this doesn't work with certificate manager

egress you can avoid data exfiltration
because you can apply policy
on where the traffic goes
does it do DNS resolution?????

rate limiting too

is better to use quickly over tls??????

egress - virtual service

tls 1.3 tried to fix it and fight with middleware
but cloudflare will put it????

mapping between dbs anme and ip is pushed down to layer 3

** multi clyser

NOW

one istio control and one kuberntes
and you need to vpn this togheter
a little better with gpc
becaus epods gets vpcip
that is google magic
and global ingresses

one shared istio conrol plane
BAD
abandoned k8s federation
you can't HA, latency problem (mixer)

POSSIBLE FUTURE

boundary should be the cluster
layer 3 is one cluster
that's your boundary

so a lot of separate network
no vpn togheter
no clugging togheter
tetrate wnats to use the ingress


- serviceentry: what names exists or allowd to be used (usually you don't see it)
you can't see them??? ioctal?  (layer 7) you need to touch this only when you want to
route to something outsie the mesh
- virtualservice: bind to gateway. - for a name, how do i rute to backends? (layer 7)
- destinationrule: how do I talk to those backend
- gateway: expose this VS to the outside world. ingress controller (open a port to the external world) if you see this host, do this

service entry is internal, gateway is for external traffic

gatweay object on the ingress controller
and virtual service to connect to the inside service
TETRATE
service engine? to say where this name is (if exists) and where to point to (which othe ringress)
and this will point it to the next hop

you need to change the global name
so is optin
if global is in the cluster you are in
.global will go locally
through gthe hidden mesh name

is optn in by Default
you need to change the name
.global

gateway and virtual service

the gateway is called mesh
the one istio creates by himself

dnat???

istio ignores namespaces???

istio is gonna do a dns resolution
get the ip
and put the name in the header
then drop the ip

istio knows about the name

the dns resolution is failing
revirews.global exists
if the dns resoltuion works it's ok
if a dns exists
but it doesn't matter the ip

coredns plugin to
coredns takes plugin
via grpc so you can put it sparately
and it has hot reload
it looks at the services and create some so at least it resolves

sky dns doesn't work this ways

istio through your ip away????

* Changelog

There is no changelog, this is the best we have:

- [[https://istio.io/about/notes/][Release notes]]
- [[https://github.com/istio/istio/wiki/v0.2.9]]

Notable changes follow.

** 0.3

- HA
- Better RBAC support
- Mutual tsl

** 0.2.6

- [[https://github.com/istio/istio/wiki/v0.2.6]]
- RBAC beta
- Initialisers

* Resources

- Me: Notes from London Kubernetes Meetup -  October 2017
- Video: [[https://www.youtube.com/watch?v=wq1nlJNvy1w][Setting Sail with Istio [B] - Lachlan Evenson, Microsoft]]
- Video: [[https://www.youtube.com/watch?v=Bh7sWtrkijY][Istio 0.2 automatic sidecar injection using Kubernetes Initializers]] - 6 Oct 2017
- [[https://www.youtube.com/watch?v=s4qasWn_mFc][Youtube: Istio and Kubernetes - Kelsey Hightower]] Jul 2017
- [[https://www.safaribooksonline.com/library/view/velocity-conference-2017/9781491976265/video311439.html]] (safari book)
- [[https://www.youtube.com/watch?v=IfPt3z6UAGw][JavaDay UA 2017: 8 Steps to Become Awesome with Kubernetes (Burr Sutter)]]
- [[https://www.youtube.com/watch?v=wq1nlJNvy1w][Setting Sail with Istio [B] - Lachlan Evenson, Microsoft]]
- [[https://medium.com/@mattklein123/service-mesh-data-plane-vs-control-plane-2774e720f7fc]]
